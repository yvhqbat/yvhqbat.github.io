
## 1. 同步

### 1.1 临界区
**临界区**, 就是访问和操作共享数据的代码段.  
多个线程并发访问一个资源通常是不安全的, 为了避免在临界区并发访问, 必须保证这些代码原子地执行.

### 1.2 竞争条件
如果两个线程处于同一个临界区中同时执行, 就是产生**竞争条件**.  

### 1.3 同步
避免并发和防止竞争条件, 称为**同步**(synchronization).


## 2. 锁
我们需要一种方法, 确保一次有且只有一个线程对数据进行操作. 或者当另一个线程在对临界区标记时, 就禁止(或者说锁定)其他访问.

**锁**提供的就是这样一种机制: 它如同一把门锁, 门后的房间可想象成一个临界区. 在一个指定时间内, 房间里只能有一个执行线程存在, 当一个线程进入房间后, 它会锁住身后的房门; 当它结束对共享数据的操作后, 就会走出房间, 打开门锁.  
如果另一个线程在房门上锁时来了, 那么它就必须等待房间内的线程出来并打开门锁后, 才能进入房间.  
这样, 线程持有锁, 而锁保护了数据.

## 3. 死锁
### 3.1 死锁产生的四个条件
1. 互斥
2. 禁止抢占
3. 持有和等待
4. 循环等待

### 3.2 死锁类型
1. 自死锁
如果一个执行线程试图去获得一个自己已经持有的锁, 它将不得不等待锁被释放, 但因为它正忙着等待这个锁, 所以自己永远也不会有机会释放锁, 最终结果就是死锁.
```
获得锁
再次试图获得锁
等待锁重新可用
...
```
PS: 可看看  递归锁

2. ABBA死锁
考虑有n个线程和n个锁, 如果每个线程都持有一把其他线程需要得到的锁, 那么所有的线程都将阻塞地等待它们希望得到的锁重新可用.  
最常见的例子是有两个线程和两把锁, 通常叫做 **ABBA死锁**.

**线程1** | **线程2**
--|--
获得锁A | 获得锁B
试图获得锁B | 试图获得锁A
等待锁B | 等待锁A

### 3.3 预防死锁
1. 按顺序加锁.   
使用嵌套的锁时必须保证以相同的顺序获取锁, 这样可以阻止致命拥抱类型的死锁(ABBA死锁, 多个锁).  
最好能记录下锁的顺序, 以便其他人也能照此顺序使用.
2. 防止发生饥饿  
3. 不要重复请求同一个锁
4. 设计应力求简单  
越复杂的加锁方案越有可能造成死锁.
