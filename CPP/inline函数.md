## inline 函数
1. 看起来像函数, 用起来像函数, 比宏好得多.  
    - inline 函数和宏的异同.
2. 免除函数调用成本.
3. 对inline 函数的每一个调用都以函数本体替换, 可能增加目标码大小, 造成代码膨胀.   
   在内存有限的机器上, 即使拥有虚拟内存, 也会导致额外的换页行为, 降低指令高速缓存装置的击中率, 以及伴随而来的效率损失.
4. inline 只是对编译器的一个申请, 不是强制指令. 分为隐喻方式和明确声明.  
    - 隐喻方式, 是将函数定义于class内.(成员函数和friend函数);  
      换句话说就是, 定义于class内的成员函数, 是隐喻的inline 函数.
    - 明确声明, 函数定义式前加关键字inline.
5. inline 函数通常一定被置于头文件内.  
    inlining在大多数C++程序中时编译期行为, 而为了将一个"函数调用"替换为"被替换函数的本体", 编译器必须知道那个函数长什么样子.
6. inline 函数无法随着程序库的升级而升级, 一旦inline 函数改变, 必须重新编译.
7. 大多数inline函数限制在小型、被频繁调用的函数身上。

## inline 函数和 宏 的异同
1. 宏 看起来像函数, 可免除函数调用成本. 这点和 inline 相同.
2. 宏 中所有参数加上小括号, 否则可能遭遇麻烦.  
   `#define CALL_WITH_MAX(a, b) f((a)>(b)?(a):(b))`
3. inline 函数获得 宏 带来的效率以及一般函数的所有可预料行为和"类型安全性".
4. #define 并不重视作用域, 而inline 函数遵守作用域和访问规则.  
   可以写出一个class内的inline函数, 但宏不行.
